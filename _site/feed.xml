<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-02-25T00:28:29+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Hwi’s footsteps</title><subtitle>Artificial Intelligence and Computer Science Study Notes.</subtitle><author><name>Shin Hwi Jeong</name></author><entry><title type="html">Swea ) 프로그래밍과 논리, 수학 1 복사본</title><link href="http://localhost:4000/SWEA-)-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EA%B3%BC-%EB%85%BC%EB%A6%AC,-%EC%88%98%ED%95%99-1-%EB%B3%B5%EC%82%AC%EB%B3%B8.html" rel="alternate" type="text/html" title="Swea ) 프로그래밍과 논리, 수학 1 복사본" /><published>2022-02-24T00:00:00+09:00</published><updated>2022-02-24T00:00:00+09:00</updated><id>http://localhost:4000/SWEA%20)%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EA%B3%BC%20%EB%85%BC%EB%A6%AC,%20%EC%88%98%ED%95%99%201%20%EB%B3%B5%EC%82%AC%EB%B3%B8</id><content type="html" xml:base="http://localhost:4000/SWEA-)-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EA%B3%BC-%EB%85%BC%EB%A6%AC,-%EC%88%98%ED%95%99-1-%EB%B3%B5%EC%82%AC%EB%B3%B8.html"><![CDATA[<p>오늘은 삼성 SW Expert Academy의 프로그래밍과 논리, 수학 강의 1강을 보고 학습한 내용을 정리해보았습니다</p>

<hr />

<h6 id="강의-링크">강의 링크</h6>

<p>https://swexpertacademy.com/main/learn/course/lectureVideoPlayer.do</p>

<hr />

<h6 id="강의-전체-목차">강의 전체 목차</h6>

<ul>
  <li>프로그래밍과 논리/수학 ( 오늘의 분량 )</li>
  <li>논리와 증명 ( 오늘의 분량 )</li>
  <li>수와 표현</li>
  <li>집합과 조합론</li>
  <li>기초 수식</li>
  <li>재귀</li>
  <li>동적 프로그래밍</li>
  <li>조합론 프로그램 과제</li>
  <li>기초 알고리즘 프로그램 과제</li>
</ul>

<hr />]]></content><author><name>Shin Hwi Jeong</name></author><summary type="html"><![CDATA[오늘은 삼성 SW Expert Academy의 프로그래밍과 논리, 수학 강의 1강을 보고 학습한 내용을 정리해보았습니다]]></summary></entry><entry><title type="html">[ex_15]문자를 읽을 수 있는 딥러닝</title><link href="http://localhost:4000/ex_15-%EB%AC%B8%EC%9E%90%EB%A5%BC-%EC%9D%BD%EC%9D%84-%EC%88%98-%EC%9E%88%EB%8A%94-%EB%94%A5%EB%9F%AC%EB%8B%9D.html" rel="alternate" type="text/html" title="[ex_15]문자를 읽을 수 있는 딥러닝" /><published>2022-02-24T00:00:00+09:00</published><updated>2022-02-24T00:00:00+09:00</updated><id>http://localhost:4000/%5Bex_15%5D%EB%AC%B8%EC%9E%90%EB%A5%BC%20%EC%9D%BD%EC%9D%84%20%EC%88%98%20%EC%9E%88%EB%8A%94%20%EB%94%A5%EB%9F%AC%EB%8B%9D</id><content type="html" xml:base="http://localhost:4000/ex_15-%EB%AC%B8%EC%9E%90%EB%A5%BC-%EC%9D%BD%EC%9D%84-%EC%88%98-%EC%9E%88%EB%8A%94-%EB%94%A5%EB%9F%AC%EB%8B%9D.html"><![CDATA[<p>오늘은 아이펠 Exploration 노드 15번을 공부하고 공부한 내용을 포스팅해보았습니다.</p>

<hr />

<h6 id="출처">출처</h6>

<ul>
  <li>
    <p>AIFFEL LMS</p>

    <p>문제시 연락 부탁드립니다. :)</p>
  </li>
</ul>

<hr />

<h6 id="목차">목차</h6>

<ul>
  <li>기계는 어떤 방식으로 글을 읽을까?
    <ul>
      <li>딥러닝 문자 인식의 시작</li>
    </ul>
  </li>
  <li>사진 속 문자 찾아내기 - detection</li>
  <li>사진 속 문자 읽어내기 - recognition</li>
  <li>keras-ocr 써보기</li>
  <li>테서랙트 써보기</li>
  <li>프로젝트 : 다양한 OCR 모델 비교하기</li>
</ul>

<hr />

<h1 id="기계는-어떤-방식으로-글을-읽을까">기계는 어떤 방식으로 글을 읽을까?</h1>

<h2 id="딥러닝-문자-인식의-시작">딥러닝 문자 인식의 시작</h2>

<h1 id="사진-속-문자-찾아내기---detection">사진 속 문자 찾아내기 - detection</h1>

<h1 id="사진-속-문자-읽어내기---recognition">사진 속 문자 읽어내기 - recognition</h1>

<h1 id="keras-ocr-써보기">keras-ocr 써보기</h1>

<h1 id="테서랙트-써보기">테서랙트 써보기</h1>

<h1 id="프로젝트--다양한-ocr-모델-비교하기">프로젝트 : 다양한 OCR 모델 비교하기</h1>]]></content><author><name>Shin Hwi Jeong</name></author><summary type="html"><![CDATA[오늘은 아이펠 Exploration 노드 15번을 공부하고 공부한 내용을 포스팅해보았습니다.]]></summary></entry><entry><title type="html">Swea ) 프로그래밍과 논리, 수학 1</title><link href="http://localhost:4000/SWEA-)-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EA%B3%BC-%EB%85%BC%EB%A6%AC,-%EC%88%98%ED%95%99-1.html" rel="alternate" type="text/html" title="Swea ) 프로그래밍과 논리, 수학 1" /><published>2022-02-24T00:00:00+09:00</published><updated>2022-02-24T00:00:00+09:00</updated><id>http://localhost:4000/SWEA%20)%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EA%B3%BC%20%EB%85%BC%EB%A6%AC,%20%EC%88%98%ED%95%99%201</id><content type="html" xml:base="http://localhost:4000/SWEA-)-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EA%B3%BC-%EB%85%BC%EB%A6%AC,-%EC%88%98%ED%95%99-1.html"><![CDATA[<p>오늘은 삼성 SW Expert Academy의 프로그래밍과 논리, 수학 강의 1강을 보고 학습한 내용을 정리해보았습니다</p>

<hr />

<h6 id="강의-링크">강의 링크</h6>

<p>https://swexpertacademy.com/main/learn/course/lectureVideoPlayer.do</p>

<hr />

<h6 id="강의-전체-목차">강의 전체 목차</h6>

<ul>
  <li>프로그래밍과 논리/수학 ( 오늘의 분량 )</li>
  <li>논리와 증명 ( 오늘의 분량 )</li>
  <li>수와 표현</li>
  <li>집합과 조합론</li>
  <li>기초 수식</li>
  <li>재귀</li>
  <li>동적 프로그래밍</li>
  <li>조합론 프로그램 과제</li>
  <li>기초 알고리즘 프로그램 과제</li>
</ul>

<hr />

<h1 id="프로그래밍과-논리--수학">프로그래밍과 논리 / 수학</h1>

<ul>
  <li>
    <p>프로그래밍이 어려운 이유</p>

    <ul>
      <li>
        <p>능숙해지기 위해 많은 훈련이 필요하지만, 이 과정의 중요 목표는 아님!</p>
      </li>
      <li>
        <p>논리적인 어려움 존재</p>

        <ul>
          <li>
            <p>ex ( 카드문제 )</p>

            <ul>
              <li>
                <p>사실과, 주장, 문제에서 사실과 주장을 잘 구분해야한다!</p>
              </li>
              <li>
                <p>사실 : 모든 카드의 한쪽에는 알파벳, 다른쪽에는 숫자</p>
              </li>
              <li>
                <p>주장 : 만약 한쪽이 D이면 반대쪽은 3</p>
              </li>
              <li>
                <p>문제 : 주장이 사실인지 확인하기 위해 아래 카드 중 반드시 뒤집어봐야 하는 카드는 몇개이고 어느것인가?</p>

                <p><img src="../assets/img/posts/image-20220224183257085.png" alt="image-20220224183257085" /></p>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>정답 : D와 7</p>
</blockquote>

<p>D를 뒤집어 봐야한다는 것은, 3인지를 확인해야하기 위함이고,</p>

<p>7을 뒤집어 봐야하는 것은 다른 숫자가 적힌 카드의 뒷면에는 D가 없는지를 확인해봐야하기 때문.</p>

<p>여기서 F는 확인 안해도 되는 것이 <del>이미 이미 D와 3에 위반된 조건이기 때문이다.</del></p>

<p>F의 뒤에 3이 있을지 걱정하는 경우인데, 주장은 D 뒤에 3이있다는 것이지 F뒤에 3이 잇으면 안된다가 아님! <strong>3이 있던 없던 상관없음!</strong></p>

<p>그렇담 3은 확인 안해도 되는것인가? 이건 F의 문제와 귀결되네. <strong>D뒤에 3이 존재하는것을 주장</strong>하는 거지 3 뒤에 그 어떤것이 와도 상관없다는 것!</p>

<p>7을 뒤집어야 하는 이유는 7뒤에 D가 있으면 <strong>주장이 깨어지기 때문!</strong></p>

<p><del>나는 여기서 궁금한 것이, 카드가 저기 4장뿐인가 라는 생각은 할 필요가 없는것인가. 카드 종류가 다양할 수 있잖아. 이 경우에는 전부 다 뒤집어야 하나?</del> 주장을 제대로 파악하지 못해서 생긴 문제다.</p>

<ul>
  <li>논리 != 직관
    <ul>
      <li>직관이란, 논리적인 <strong>느낌</strong>을 주는 것.
        <ul>
          <li>장점은 익숙한 상황에서는 매우 빠름</li>
          <li>단점은 정확하지 않다. 가끔은 익숙한 상황에서도 틀릴 수 있다.</li>
          <li>또한, 강한 착각을 일으킬 수 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="논리와-증명">논리와 증명</h1>

<ul>
  <li>soft logic
    <ul>
      <li>논리적으로 부정확한 표현을 사용하지만, 어떤 의미인지 모든 사람이 알고있다는 가정</li>
    </ul>
  </li>
  <li>hard logic
    <ul>
      <li>프로그래밍 언어 표현의 모두 논리학에서 나온 것입니다.</li>
      <li>사용되고 있는 수 많은 알고리즘을 이해하기 위해서는 hard logic이 필요하다.</li>
    </ul>
  </li>
  <li>프로그래밍의 어려움에는 soft logic으로 알고리즘을 이해하려고 하는 것입니다.
    <ul>
      <li>알고리즘 설명을 보고 또 봐도 이해가 안되는 것은 증명을 안봤기 때문</li>
      <li>증명을 봐도 이해가 안되는 것은 직관으로 이해하려고 하기 때문.</li>
      <li>직관으로 완전한 이해를 얻는 것은 불 가 능</li>
    </ul>
  </li>
</ul>

<h2 id="논리연습-1">논리연습 1</h2>

<ul>
  <li>다음을 명제식 형태로 쓰고 참인지 거짓인지 판단하시오
    <ol>
      <li>만약 0이 홀수라면, 미국에서 2080년 월드컵이 열린다.</li>
      <li>만약<img src="../assets/img/posts/image-20220224203954973.png" alt="image-20220224203954973" />이 prime number라면 2는 짝수이다.</li>
    </ol>
  </li>
</ul>

<blockquote>
  <p>1.</p>

  <p>p 이면 q이다 라는 명제에서 p는 0이 홀수이다. q는 미국에서2080년 월드컵이 열린다 입니다.</p>

  <p><del>p이면 q이다 의 명제의 전제는 p가 참일 경우입니다. p가 거짓이면 명제식 자체가 거짓이 됩니다.</del></p>

  <p>p이면 q이다 (참)</p>

  <p>p이면 ~q이다 (거짓)</p>

  <p>~p이면 q이다 (참)</p>

  <p>~p이면 ~q이다 (참)</p>

  <p>p이면 q라고 주장했지, ~p이면 ~q라고 말한게 아닙니다!</p>

  <p>즉, ~p이면 q, ~q 둘 다 참입니다.</p>

  <p><strong>가정이 거짓이되면 전체는 참이됩니다.</strong></p>

  <p>1번 : 참</p>
</blockquote>

<blockquote>
  <p>2.</p>

  <p>p 이면 q이다 라는 명제에서 p는 저 숫자가 prime numer이다. q는 2는 짝수이다. 입니다.</p>

  <p>p의 사실 여부와 상관없이, q가 항상 참이므로, 2번 명제는 항상 참입니다. p가 참이어도 결론 q는 참, p가 거짓이어도 결론 q는 참이기 때문입니다.</p>
</blockquote>

<h2 id="논리-연습2">논리 연습2</h2>

<p>p와 q가 명제이고, p -&gt; q가 거짓이라고 하자. 다음 명제식의 참 거짓은 어떻게 되는가?</p>

<p>ⓐ ~p -&gt; q</p>

<p>ⓑ p V q</p>

<p>ⓒq -&gt; p</p>

<p>생각정리.</p>

<p>p가 참이면 q의 참 거짓에 따라 거짓이 판별됨.</p>

<p>p가 거짓이면 q는 항상 참이다.</p>

<p>근데, q는 거짓이라그랬으니까, p는 참인데, q가 거짓인 경우뿐이네!</p>

<p><del>즉, 참인 경우 : ~q or q -&gt; p인 경우 (c) ,거짓인 경우 : ~p -&gt; q인 경우 (a)</del></p>

<p>(a) : 참 (가정이 거짓이 되면 전체는 참이 되기 때문입니다.)</p>

<p>(b) : 참 (참 과 거짓 이면 참입니다.)</p>

<p>(c) : 참</p>

<blockquote>
  <p>b의 문법은 뭘까요?</p>

  <p>p와 q 합집합으로 이해하면 됩니다.</p>
</blockquote>

<h2 id="논리-연습-3">논리 연습 3.</h2>

<p>다음 명제들의 역 이 대우를 쓰시오</p>

<ol>
  <li>만약 0이 홀수라면, 미국에서 2080년 월드컵이 열린다.</li>
  <li>
    <p>만약 <img src="../assets/img/posts/image-20220224205958021.png" alt="image-20220224205958021" />가 prime number라면 2는 짝수이다.</p>
  </li>
  <li>
    <p>역 : 만약 미국에서 2080년 월드컵이 열린다면 0이 홀수이다.</p>
  </li>
  <li>
    <p>이 : 만약 0이 홀수가 아니라면, 미국에서 2080년 월드컵이 열리지 않는다.</p>
  </li>
  <li>대우 : 미국에서 2080년 월드컵이 열리지 않는다면, 0이 홀수가 아니다.</li>
  <li>
    <p>역 : 만약 2가 짝수라면저 숫자는 prime number이다.</p>
  </li>
  <li>
    <p>이 : 만약 저 숫자가 prime number가 아니라면, 2는 짝수가 아니다.</p>
  </li>
  <li>대우 : 2가 짝수가 아니라면, 저 숫자가 prime number가 아니다.</li>
</ol>

<h2 id="논리-연습-4">논리 연습 4.</h2>

<p><img src="../assets/img/posts/image-20220224210624355.png" alt="image-20220224210624355" /></p>

<ol>
  <li><img src="../assets/img/posts/image-20220224212544120.png" alt="image-20220224212544120" /></li>
</ol>

<ul>
  <li>증명이란?
    <ul>
      <li>정확한 명제식으로 표현할 수 있는 것이라야 함</li>
      <li>보통은 정확한 명제식까지 쓰지는 않으나 근본적으로는 명제식으로 바꿀 수 있음</li>
    </ul>
  </li>
</ul>

<h2 id="당구공-paradox">당구공 paradox</h2>

<p><img src="../assets/img/posts/image-20220224212905380.png" alt="image-20220224212905380" /></p>

<p><img src="../assets/img/posts/image-20220224213249351.png" alt="image-20220224213249351" /></p>

<ul>
  <li>
    <p>수학적 귀납법이란?</p>

    <ul>
      <li>
        <p>자연수 n에 관한 명제 P(n)이 모든 자연수 n에 대하여 성립함을 다음과 같이 증명하는 방법</p>

        <p>자연수 n에 관한 어떤 명제 P(n)에 대하여</p>

        <p>(1) n = 1일 때, 즉 P(1)이 성립함을 증명하고,</p>

        <p>(2) n = k일 때, 즉 P(k)가 성립한다고 가정하면 n = k+1일 때, 즉 P(k+1)도 성립함을 증명한다.</p>
      </li>
    </ul>
  </li>
  <li>
    <p>대부분 사람들이 P(n)이 참이라고 가정할 수없다고 반론함.</p>

    <ul>
      <li><strong>수학적 귀납법에서 필요한 것은 P(n)-&gt;P(n+1)이 참임을 보이는 것 뿐이므로, P(n)이 정말로 참일 필요는 없음.</strong>
        <ul>
          <li><del>P(n)이 거짓이면 전부 통째로 참이되어버리니까 오히려 좋아</del></li>
        </ul>
      </li>
      <li>위 증명에서 실제로 잘못된 부분은
        <ul>
          <li>위의 두 상황에서 처음 뺀 당구공과 두번째로 뺀 당구공의 색이 같음을 알수있으므로,,,</li>
        </ul>
      </li>
      <li>처음뺀 당구공과 두번째로 뺀 당구공의 색이 같다는 것은 공통부분이 있다는 것인데, 실제로 n = 1인 경우, 즉, n+1=2인 경우 공통부분이 없다.
        <ul>
          <li>n=1인 경우에는 주머니안에 있는 공들의 색이 전부 같다는게 아니라, n=1인경우에는 주머니에 그 공 하나라서 색이 같을 수 밖에 없다는 것이므로 성립하지 않는대.</li>
          <li>조금 이해가 안되는 부분이 공을 뺐을 때 다른색깔일 경우는 생각조차 안하는건가?</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="infinitely-many-prime-numbers">Infinitely Many Prime Numbers</h2>

<p><img src="../assets/img/posts/image-20220224224029944.png" alt="image-20220224224029944" /></p>

<ul>
  <li>Prime number란?
    <ul>
      <li>소수를 의미하며, 1과 자기 자신으로만 나누어 떨어지는 1보다 큰 양수입니다.</li>
    </ul>
  </li>
  <li>
    <p>설명</p>

    <ul>
      <li>prime number의 수가 유한하며 (조건1), 모든 prime 수를 다 곱하고 1을 더한 수를 n이라고 하면 이 n은 prime number가 아니게 된다.
        <ul>
          <li>모든 소수보다도 큰 수이기 떄문에 소수가 될 수없다. 그렇기 때문에 이 수는 인수분해가 되어야 한다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>반론</p>

    <ul>
      <li>작성은스킵</li>
    </ul>
  </li>
</ul>

<h1 id="버블-소트-증명">버블 소트 증명</h1>

<p><img src="../assets/img/posts/image-20220224233546030.png" alt="image-20220224233546030" /></p>]]></content><author><name>Shin Hwi Jeong</name></author><summary type="html"><![CDATA[오늘은 삼성 SW Expert Academy의 프로그래밍과 논리, 수학 강의 1강을 보고 학습한 내용을 정리해보았습니다]]></summary></entry><entry><title type="html">[fd_30] computer power up</title><link href="http://localhost:4000/fd_30-Computer-Power-UP.html" rel="alternate" type="text/html" title="[fd_30] computer power up" /><published>2022-02-23T00:00:00+09:00</published><updated>2022-02-23T00:00:00+09:00</updated><id>http://localhost:4000/%5Bfd_30%5D%20Computer%20Power%20UP</id><content type="html" xml:base="http://localhost:4000/fd_30-Computer-Power-UP.html"><![CDATA[<p>오늘은 아이펠 Fundamental 노드 30번을 공부하고 공부한 내용을 포스팅해보았습니다.</p>

<p>깃허브 주소 : https://github.com/Nega0619/Aiffel_Fundamental_nodes/blob/main/%5Bfd_30%5D%20Computer%20Power%20UP.ipynb</p>

<hr />

<h6 id="출처">출처</h6>

<ul>
  <li>
    <p>AIFFEL LMS</p>

    <p>문제시 연락 부탁드립니다. :)</p>
  </li>
</ul>

<hr />

<h6 id="목차">목차</h6>

<ul>
  <li>멀티태스킹
    <ul>
      <li>멀티태스킹이란?</li>
      <li>프로세스, 스레드, 프로파일링</li>
      <li>Scale-up VS Scale-out</li>
    </ul>
  </li>
  <li>멀티프로세스, 멀티 스레드
    <ul>
      <li>멀티스레드</li>
      <li>멀티프로세스</li>
      <li>스레드 / 프로세스 풀</li>
    </ul>
  </li>
  <li>실전예제</li>
</ul>

<hr />

<h1 id="1-멀티태스킹">1. 멀티태스킹</h1>

<h2 id="1-1-멀티태스킹이란">1-1. 멀티태스킹이란?</h2>

<p>자원을 최적화하는 법, 병렬 컴퓨팅, 분산컴퓨팅의 개념은 빅데이터를 다루기 위해선 꼭 알고있어야 하는 중요한 개념들입니다. 한정된 컴퓨팅 자원을 활용하여 여러가지 일을 효율적으로 진행할 수 있도록 해주는 것을 멀티태스킹이라고 합니다. 멀티태스킹은 동시성 병렬성을 가지고 있으며 다음 글을 참고하니 이해하기 쉬웠습니다.</p>

<ul>
  <li><a href="https://techdifferences.com/difference-between-concurrency-and-parallelism.html">Difference Between Concurrency and Parallelism</a>
    <ul>
      <li>동시성 : 동시에 많은 것을 처리함(동시성의 환상을 제공)</li>
      <li>병렬성 : 속도를 높이기 위해 동시에 많은 일을 하는 것.</li>
    </ul>
  </li>
</ul>

<h3 id="동시성">동시성</h3>

<p>하나의 Processor가 여러가지 task를 동시에 수행하는 개념</p>

<p>즉, processor가 특정 순간에 1가지 task만을 수행하지만, 라면을 끓일때 물 끓기까지 기다리는 것 처럼 다른 task를 수행할 수 있는 시간에 task를 전환하여 task를 여러개 수행하는 것 처럼 보이게 하는 것입니다.</p>

<h3 id="병렬성">병렬성</h3>

<p>유사한 task를 여러 processor가 동시에 수행하는 개념</p>

<p>병렬성의 효율을 극대화 시키기 위해서는 동시성이 같이 요구되어야 한다.</p>

<h3 id="동기-vs-비동기-synchronious-vs-asynchronous">동기 vs 비동기 (synchronious vs asynchronous)</h3>

<p>동기와 비동기는 동시성에서 주로 다루게 되는 개념입니다.</p>

<p>컴퓨터에서 어떤 일을 바로 하지 못하고 대기해야 하는 경우를 일컬어 <code class="language-plaintext highlighter-rouge">바운드(bound)되었다.</code>라는 표현을 쓴다고 합니다.</p>

<p>바운드 되었을때, 앞 작업이 기다리기를 하염없이 기다리다 다음 작업을 시작하는 것을 동기(synchronize)라고 하고, 바운드 되고 있는 작업을 기다리는 동안 다른 일을 처리하는 것을 비동기(asynchronize)라고 합니다.</p>

<ul>
  <li>동기 : 일이 순차적으로 진행되며, 요청과 요청에 대한 응답이 연속적으로 실행</li>
  <li>비동기 : 일이 비순차적으로 진행되며, 요청과 요청에 대한 응답이 비연속적으로 실행. 특정 코드의 연산이 끝날 때 까지 코드 실행을 멈추지 않으며 다음코드를 실행하고 중간에 실행되는 코드는 콜백함수로 연결하여 처리하기도 함</li>
</ul>

<h3 id="io-bound-vs-cpu-bound">I/O Bound VS CPU Bound</h3>

<p>컴퓨터가 일을 수행하면서 뭔가를 기다릴 때, 즉 속도 제한이 걸리는 경우는 2가지입니다.</p>

<ul>
  <li>I/O Bound : 입 출력에서 데이터 처리에 시간이 소요되는 경우</li>
  <li>CPU Bound : 복잡한 수식이나 그래픽 작업과 같은 많은 계산이 요구되는 경우</li>
</ul>

<h2 id="1-2-프로세스-스레드-프로파일링">1-2. 프로세스, 스레드, 프로파일링</h2>

<h3 id="프로세스-process">프로세스 Process</h3>

<p>프로세스란 프로그램을 구동해 프로그램 자체와 프로그램의 상태가 메모리상에서 실행되는 작업의 단위입니다. 하나의 프로그램을 실행할 때, 운영체제는 프로세스를 한개를 생성합니다.</p>

<p>프로세스는 운영체제의 커널(Kernel)에서 시스템 자원(CPU, 메모리, 디스크) 과 자료구조를 이용합니다.</p>

<h3 id="스레드-thread">스레드 Thread</h3>

<p>스레드(thread)란 어떠한 프로그램 내에서 즉, 프로세스 내에서 실행되는 흐름의 단위</p>

<p>예를 들어 요리를 만드는 프로그램이 존재한다고 한다면, 요리사는 프로세스, 재료썰기, 밥짓기, 볶기 등의 작업을 스레드에 비유할 수 있습니다. 같은 작업을 빠르게 처리하기 위해 여러 개의 스레드를 생성하기도 합니다.</p>

<p>각각의 작업을 할 때 도마나 불판 등의 주방 공간은 공유되지만 요리사 각자의 주방 공간은 공유하지 않습니다. 마찬가지로 프로세스도 자신만의 전용 메모리 공간 (Heap)을 가집니다.그렇기때문에 스레드들도 메모리 공간자체는 공유 하지만 다른 프로세스와 공유하지는 않습니다.</p>

<p><img src="../assets/img/posts/image-20220223135657027.png" alt="image-20220223135657027" /></p>

<h3 id="프로파일링-profiling">프로파일링 Profiling</h3>

<p>프로파일링이란 것은, 코드에서 시스템의 어느 부분이 느린지 혹은 어디에서 RAM을 많이 사용하고 있는지 확인하고 싶을때 사용하는 기법입니다.</p>

<p>프로파일링은 애플리케이션에서 자원이 가장 집중되는 지점을 정밀하게 찾아내는 기법입니다.</p>

<p>프로파일링은 애플리케이션을 실행시키고 각각의 함수 실행 시간을 재는 프로그램입니다.</p>

<p>프로파일링은 코드의 병목(bottleneck)을 찾아내고 성능을 측정해주는 도구입니다.</p>

<ul>
  <li>참고링크
    <ul>
      <li><a href="https://docs.python.org/ko/3/library/profile.html">파이썬 프로파일러 - cProfile, profile</a></li>
      <li><a href="https://frhyme.github.io/python-libs/python_line_profileing_in_python/">line profiler를 사용하여 파이썬의 각 라인이 어떻게 돌아가는지를 알아보자.</a></li>
    </ul>
  </li>
</ul>

<h2 id="scale-up-vs-scale-out">scale-up VS scale-out</h2>

<ul>
  <li>scale-up : 컴퓨터 자원을 활용하기 위해서 자원을 업그레이드/최적화 시키는 것
    <ul>
      <li>한대의 컴퓨터 성능을 최적화 시키는 것</li>
    </ul>
  </li>
  <li>scale-out :컴퓨터 자원을 활용하기 위해서 자원을 확장 시키는 것
    <ul>
      <li>여러대의 컴퓨터를 한 대처럼 사용하는 것</li>
    </ul>
  </li>
</ul>

<h1 id="1-3-멀티-프로세스-멀티스레드">1-3. 멀티 프로세스, 멀티스레드</h1>

<h2 id="멀티스레드">멀티스레드</h2>

<p>파이썬에서 멀티스레드 구현은 <a href="https://docs.python.org/3.7/library/threading.html">threading 모듈</a>을 이용합니다.</p>

<ul>
  <li>
    <p>생성방법 1. 클래스에 Thread 상속받기</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Class</span> <span class="n">Delivery</span><span class="p">(</span><span class="n">Thread</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"배달이요"</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>생성방법 2. Thread 인스턴스화</p>

    <p>t = Thread(target=함수이름, args=())</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">sleep</span>
  
<span class="n">Stopped</span> <span class="o">=</span> <span class="bp">False</span>
  
<span class="k">def</span> <span class="nf">worker</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">sleep_sec</span><span class="p">):</span>    <span class="c1"># 일꾼 스레드입니다.
</span>    <span class="k">while</span> <span class="ow">not</span> <span class="n">Stopped</span><span class="p">:</span>          <span class="c1"># 그만 하라고 할때까지
</span>        <span class="k">print</span><span class="p">(</span><span class="s">'do '</span><span class="p">,</span> <span class="n">work</span><span class="p">)</span>      <span class="c1"># 시키는 일을 하고
</span>        <span class="n">sleep</span><span class="p">(</span><span class="n">sleep_sec</span><span class="p">)</span>        <span class="c1"># 잠깐 쉽니다.
</span>    <span class="k">print</span><span class="p">(</span><span class="s">'retired..'</span><span class="p">)</span>          <span class="c1"># 언젠가 이 굴레를 벗어나면, 은퇴할 때가 오겠지요?
</span>          
<span class="n">t</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">worker</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="s">'Overwork'</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>    <span class="c1"># 일꾼 스레드를 하나 생성합니다. 열심히 일하고 3초간 쉽니다.
</span><span class="n">t</span><span class="p">.</span><span class="n">start</span><span class="p">()</span>    <span class="c1"># 일꾼, 이제 일을 해야지? 😈
</span></code></pre></div>    </div>

    <ul>
      <li>
        <p>스레드 멈추기</p>

        <p>t.terminate() 메소드는 없으므로 멈추려면 flag를 체크해서 멈추도록 합니다.</p>

        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 이 코드 블럭을 실행하기 전까지는 일꾼 스레드는 종료하지 않습니다. 
</span><span class="n">Stopped</span> <span class="o">=</span> <span class="bp">True</span>    <span class="c1"># 일꾼 일 그만하라고 세팅해 줍시다. 
</span><span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">()</span>          <span class="c1"># 일꾼 스레드가 종료할때까지 기다립니다. 
</span><span class="k">print</span><span class="p">(</span><span class="s">'worker is gone.'</span><span class="p">)</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>스레드 생성확인</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Delivery</span><span class="p">(</span><span class="n">Thread</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"배달이요"</span><span class="p">)</span>
  
<span class="n">work2</span> <span class="o">=</span> <span class="n">Delivery</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">work2</span><span class="p">.</span><span class="n">run</span><span class="p">)</span>
</code></pre></div>    </div>

    <p>실행결과</p>

    <blockquote>
      <p>&lt;bound method Delivery.run of &lt;Delivery(Thread-21, initial)»</p>
    </blockquote>
  </li>
</ul>

<h2 id="멀티프로세스">멀티프로세스</h2>

<ul>
  <li>
    <p>생성 방법 1. Process 인스턴스 생성</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="k">as</span> <span class="n">mp</span>
  
<span class="k">def</span> <span class="nf">delivery</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'delivering...'</span><span class="p">)</span>
  
<span class="n">p</span> <span class="o">=</span> <span class="n">mp</span><span class="p">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">delivery</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">())</span>
<span class="n">p</span><span class="p">.</span><span class="n">start</span><span class="p">()</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>프로세스 사용</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p</span> <span class="o">=</span> <span class="n">mp</span><span class="p">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">delivery</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">())</span>
<span class="n">p</span><span class="p">.</span><span class="n">start</span><span class="p">()</span> <span class="c1"># 프로세스 시작
</span><span class="n">p</span><span class="p">.</span><span class="n">join</span><span class="p">()</span> <span class="c1"># 실제 종료까지 기다림 (필요시에만 사용)
</span><span class="n">p</span><span class="p">.</span><span class="n">terminate</span><span class="p">()</span> <span class="c1"># 프로세스 종료
</span></code></pre></div>    </div>
  </li>
</ul>

<h2 id="스레드--프로세스-풀">스레드 / 프로세스 풀</h2>

<p>스레드나 프로세느는 사용할때 단독으로 사용하고 종료해주지 않고 스레드 / 프로세스 풀을 사용해서 생성합니다.</p>

<p>“풀(Pool)”은 스레드나 프로세스들로 가득 찬 풀장입니다. 스레드 풀을 만들면 각각의 태스크들에 대해서 자동으로 스레드들을 할당하고 종료합니다.</p>

<ul>
  <li>풀 만드는 방법 2가지
    <ul>
      <li><a href="https://docs.python.org/3.7/library/queue.html">Queue</a>를 사용해서 직접 만드는 방법</li>
      <li><a href="https://docs.python.org/ko/3.7/library/concurrent.futures.html">concurrent.futures</a> 라이브러리의 <code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code> , <code class="language-plaintext highlighter-rouge">ProcessPoolExecutor</code>클래스를 이용하는 방법</li>
    </ul>
  </li>
</ul>

<h3 id="concurrentfutures-모듈을-이용해서-스레드-풀-만드는-방법">concurrent.futures 모듈을 이용해서 스레드 풀 만드는 방법</h3>

<ul>
  <li>concurrent.futures 기능 4가지
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Executor</code> 객체</li>
      <li><code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code> 객체</li>
      <li><code class="language-plaintext highlighter-rouge">ProcessPoolExecutor</code> 객체</li>
      <li><code class="language-plaintext highlighter-rouge">Future</code> 객체</li>
    </ul>
  </li>
</ul>

<h4 id="threadpoolexecuter">ThreadPoolExecuter</h4>

<p><code class="language-plaintext highlighter-rouge">Executor</code> 객체를 이용하면 스레드 생성, 시작, 조인 같은 작업을 할 때, <code class="language-plaintext highlighter-rouge">with</code> 컨텍스트 관리자와 같은 방법으로 가독성 높은 코드를 구현할 수 있습니다.(프로세스도 동일)</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="n">ThreadPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
    <span class="n">future</span> <span class="o">=</span> <span class="n">executor</span><span class="p">.</span><span class="n">submit</span><span class="p">(</span><span class="n">함수이름</span><span class="p">,</span> <span class="n">인자</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="multiprocessingpool">multiprocessing.Pool</h4>

<p>multiprocessing.Pool.map을 이용하여 여러 개의 프로세스에 특정한 함수를 매핑해 병렬처리하도록 구현하는 방법이 널리 사용</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="n">Pool</span><span class="p">()</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">pool</span><span class="p">.</span><span class="nb">map</span><span class="p">(</span><span class="n">double</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
      <span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div></div>

<p>위의 메소드를 실행하면 <code class="language-plaintext highlighter-rouge">double(i)</code>이라는 메소드가 pool을 통해서 각각 다른 pid를 가진 프로세스들 위에 multiprocess로 실행되었다는 것을 확인할 수 있습니다.</p>

<h1 id="실전예제">실전예제</h1>

<p>깃허브 참고</p>]]></content><author><name>Shin Hwi Jeong</name></author><summary type="html"><![CDATA[오늘은 아이펠 Fundamental 노드 30번을 공부하고 공부한 내용을 포스팅해보았습니다.]]></summary></entry><entry><title type="html">[ex_14] find another artist that iu fans will like</title><link href="http://localhost:4000/ex_14-Find-another-artist-that-IU-fans-will-like.html" rel="alternate" type="text/html" title="[ex_14] find another artist that iu fans will like" /><published>2022-02-22T00:00:00+09:00</published><updated>2022-02-22T00:00:00+09:00</updated><id>http://localhost:4000/%5Bex_14%5D%20Find%20another%20artist%20that%20IU%20fans%20will%20like</id><content type="html" xml:base="http://localhost:4000/ex_14-Find-another-artist-that-IU-fans-will-like.html"><![CDATA[<p>오늘은 아이펠 Exploration 노드 14번을 공부하고 공부한 내용을 포스팅해보았습니다.</p>

<p>전체 코드는 깃허브를 참고하시고, 여기서는 중요한 메소드만을 작성하였습니다.</p>

<hr />

<h6 id="출처">출처</h6>

<ul>
  <li>
    <p>AIFFEL LMS</p>

    <p>문제시 연락 부탁드립니다. :)</p>
  </li>
</ul>

<hr />

<p>목차</p>

<ul>
  <li>추천 시스템이란?</li>
  <li>데이터 탐색과 전처리</li>
  <li>사용자의 명시적 / 암묵적 평가</li>
  <li>Matrix Factorization ( MF )</li>
  <li>CSR (Compressed Sparse Row) Matrix</li>
  <li>MF 모델 학습하기</li>
  <li>비슷한 아티스트 찾기 + 유저에게 추천하기</li>
</ul>

<hr />

<h1 id="1-추천시스템이란">1. 추천시스템이란?</h1>

<p>추천 시스템은 사용자가 선호할 만한 아이템을 추측함으로써 여러 가지 항목 중 사용자에게 적합 한 특정 항목을 선택(information filtering)하여 제공하는 시스템입니다.</p>

<ul>
  <li>
    <p>고전적 추천 시스템</p>

    <ul>
      <li>
        <p>협업 필터링</p>

        <ul>
          <li>
            <p>대규모의 기존 사용자 행동 정보를 분석하여 해당 사용자와 비슷한 성향의 사용자들이 기존에 좋아했던 항목을 추천하는 기술</p>
          </li>
          <li>
            <p>행렬분해(Matrix Factorization), k-최근접 이웃 알고리즘 (k-Nearest Neighbor algorithm; kNN) 등의 방법이 많이 사용</p>
          </li>
          <li>
            <p>협업 필터링을 위해서는 반드시 기존 자료를 활용 BUT 이러한 자료들을 사용자에게 직접 요구해야만 하는것은 아님</p>
          </li>
          <li>
            <p>단점</p>

            <ul>
              <li>
                <p>Cold Start</p>

                <p>협업 필터링은 기존의 자료가 필요한바, 기존에 없던 새로운 항목이 추가되는 경우는 추천이 곤란해지는 현상</p>
              </li>
              <li>
                <p>사용자 수가 많은 경우 효율 적으로 추천할 수 없음</p>

                <p>계산이 몇 시간에서 며칠까지 걸리는 경우가 종종 생김</p>
              </li>
              <li>
                <p>Long tail</p>

                <p>시스템 항목이 많다 하더라도 사용자들은 소수의 인기 있는 항목에만 관심을 보이기 마련이다. 따라서 사용자들의 관심이 적은 다수의 항목은 추천 을 위한 충분한 정보를 제공하지 못하는 경우</p>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <p>콘텐츠 기반 필터링</p>

        <ul>
          <li>항목 자체를 분석하여 추천을 구현</li>
          <li>항목을 분석한 프로파일(item profile)과 사용자의 선호도를 추출한 프로파일(user profile)을 추출하여 이의 유사성을 계산</li>
          <li>아이템 분석 알고리즘이 핵심적
            <ul>
              <li>군집분석(Clustering analysis), 인공신경망(Artificial neural network), tf-idf(term frequencyinverse document frequency) 등의 기술이 사용</li>
            </ul>
          </li>
          <li>로 협업 필터링에서 발생하는 콜드 스타트 문제 를 자연스럽게 해결</li>
          <li>단점
            <ul>
              <li>만 다양한 형식의 항목을 추천하기 어려움</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>모델 기반 협력 필터링</p>

    <ul>
      <li>
        <p>기존 항목 간 유사성을 단순하게 비교하는 것에서 벗어나 자료 안에 내재한 패턴 을 이용하는 기법</p>

        <ul>
          <li>
            <p>자료의 크기를 동적으로 변화시키는 방법</p>

            <p>영 화를 추천하는 경우, ‘해리 포터’ 시리즈 2편을 추천하기 위해서는 ‘해리 포터’ 시리즈 1편, 단 한 편을 좋아했는가가 다른 무엇보다 중요한 요소</p>
          </li>
          <li>
            <p>추천을 위한 자료의 크기를 변화시키는 방법</p>
          </li>
          <li>
            <p>잠재(latent) 모델에 기반을 둔 방법</p>

            <p>잠재 모델이란 사용자가 특정 항목을 선호 하는 이유를 알고리즘적으로 알아내는 기법</p>
          </li>
        </ul>
      </li>
      <li>
        <p>LDA(Latent Dirichlet Allocation), 베이지안 네트워크 (Bayesian Network) 등의 알고리즘이 사용</p>
      </li>
    </ul>
  </li>
  <li>
    <p>출처 : <a href="http://www.kocca.kr/insight/vol05/vol05_04.pdf">콘텐츠 추천 알고리즘의 진화</a></p>
  </li>
</ul>

<h1 id="2-데이터-탐색과-전처리">2. 데이터 탐색과 전처리</h1>

<ul>
  <li>TSV 파일이란?
    <ul>
      <li>tsv는 Tab-Separated Values의 약자로서,  구분자가 tab(‘\t’) 문자</li>
    </ul>
  </li>
  <li>CSV 파일이란?
    <ul>
      <li>csv는 Comma-Separated Values의 약자로서, 구분자가 comma(‘,’) 문자</li>
    </ul>
  </li>
  <li>
    <p>tsv 파일 읽어오기</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s">'</span><span class="se">\t</span><span class="s">'</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span> <span class="n">col_names</span><span class="p">)</span>      <span class="c1"># sep='\t'로 주어야 tsv를 열 수 있습니다.  
</span></code></pre></div>    </div>
  </li>
  <li>
    <p>pandas에서 사용할 컬럼만 남기기</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">using_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s">'user_id'</span><span class="p">,</span> <span class="s">'artist'</span><span class="p">,</span> <span class="s">'play'</span><span class="p">]</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">using_cols</span><span class="p">]</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>pandas Dataframe에서 유니크한 데이터 개수알아보기</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">data</span><span class="p">[</span><span class="s">'user_id'</span><span class="p">].</span><span class="n">nunique</span><span class="p">()</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>pandas Dataframe에서 group by 사용하기</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user_median</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">groupby</span><span class="p">(</span><span class="s">'user_id'</span><span class="p">)[</span><span class="s">'play'</span><span class="p">].</span><span class="n">median</span><span class="p">()</span>
  
</code></pre></div>    </div>
  </li>
  <li>
    <p>꼭 암기</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 아티스트 이름은 꼭 데이터셋에 있는 것과 동일하게 맞춰주세요. 
</span><span class="n">my_favorite</span> <span class="o">=</span> <span class="p">[</span><span class="s">'black eyed peas'</span> <span class="p">,</span> <span class="s">'maroon5'</span> <span class="p">,</span><span class="s">'jason mraz'</span> <span class="p">,</span><span class="s">'coldplay'</span> <span class="p">,</span><span class="s">'beyoncé'</span><span class="p">]</span>
  
<span class="c1"># 'hwi'이라는 user_id가 위 아티스트의 노래를 30회씩 들었다고 가정하겠습니다.
</span><span class="n">my_playlist</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s">'user_id'</span><span class="p">:</span> <span class="p">[</span><span class="s">'hwi'</span><span class="p">]</span><span class="o">*</span><span class="mi">5</span><span class="p">,</span> <span class="s">'artist'</span><span class="p">:</span> <span class="n">my_favorite</span><span class="p">,</span> <span class="s">'play'</span><span class="p">:[</span><span class="mi">30</span><span class="p">]</span><span class="o">*</span><span class="mi">5</span><span class="p">})</span>
  
<span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">.</span><span class="n">isin</span><span class="p">({</span><span class="s">'user_id'</span><span class="p">:[</span><span class="s">'zimin'</span><span class="p">]})[</span><span class="s">'user_id'</span><span class="p">].</span><span class="nb">any</span><span class="p">():</span>  <span class="c1"># user_id에 'zimin'이라는 데이터가 없다면
</span>    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">my_playlist</span><span class="p">)</span>                           <span class="c1"># 위에 임의로 만든 my_favorite 데이터를 추가해 줍니다. 
</span></code></pre></div>    </div>

    <ul>
      <li>
        <p><code class="language-plaintext highlighter-rouge">data = data.append(my_palylist)</code>로 하면 index 순서대로가 아닌 0 ,1, 2, 3, 4, …. , 56643,56644, 0,1,2,3,4 순으로 들어오게 됩니다.</p>

        <ul>
          <li>
            <p>인덱스 순서대로 넣게해주려면 <code class="language-plaintext highlighter-rouge">data = data.append(my_playlist, ignore_index=True) </code> 처럼 <code class="language-plaintext highlighter-rouge">ignore_index=True</code>옵션을 넣어주면 됩니다.</p>
          </li>
          <li>
            <p>https://yganalyst.github.io/data_handling/Pd_2/에서의 inplace와 drop은 안됨.</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="3-사용자의-명시적--암묵적-평가">3. 사용자의 명시적 / 암묵적 평가</h1>

<ul>
  <li>
    <p>명시적 평가 : 좋아요나 별점과 같은 사용자가 직접적으로 드러낸 데이터</p>
  </li>
  <li>
    <p>암묵적 평가 : 어떤 곡을 몇번 플레이했다 / 어떤 영화를 몇번 봤다와 같은 서비스를 이용하면서 자연스럽게 발생하는 암묵적(Implicit) 피드백</p>

    <ul>
      <li>암묵적 데이터를 사용할때 참고하면 좋을 논문 : <a href="http://yifanhu.net/PUB/cf.pdf">Collaborative Filtering for Implicit Feedback Datasets</a></li>
      <li>특징
        <ul>
          <li>부정적인 피드백이 없다.(No Negative Feedback)</li>
          <li>애초에 잡음이 많다.(Inherently Noisy)</li>
          <li>수치는 신뢰도를 의미한다.(The numerical value of implicit feedback indicates confidence)</li>
          <li>Implicit-feedback Recommender System의 평가는 적절한 방법을 고민해봐야 한다.(Evaluation of implicit-feedback recommender requires appropriate measures)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>해당 프로젝트에서는 암묵적 데이터의 해석에 대한 규칙을 다음과 같이 정했습니다.</p>

<ul>
  <li>한번이라도 들었으면 선호라고 판단</li>
  <li>많이 재생한 아티스트에 대해 가중치를 주어서 확실히 좋아한다고 판단한다.</li>
</ul>

<h1 id="4-matrix-factorization--mf-">4. Matrix Factorization ( MF )</h1>

<p>해당 프로젝트에서는 m명의 사용자들이 n명의 아티스트에 대해 평가한 데이터를 포함한 (m*n) 사이즈의 평가 행렬(Rating Matrix)을 만들었습니다.</p>

<p>행렬에는 그림과 같이 결측치가 존재하며, 추천시스템의 협업 필터링이란 이 평가행렬을 전제로합니다.</p>

<p>추천시스템의 모델은 Matrix Factorization(MF, 행렬 분해) 모델을 사용하였습니다. 기본아이디어는 <code class="language-plaintext highlighter-rouge">(m*n)</code> 사이즈의 행렬 R을 <code class="language-plaintext highlighter-rouge">(m*k)</code> 사이즈의 행렬 P와 <code class="language-plaintext highlighter-rouge">(k*n)</code>사이즈의 행렬 Q로 분해한다면 R이란 P와 Q의 행렬곱으로 표현할수 있다는 것입니다. 아이디어는 단순하지만, k는 m이나 n보다 훨씬 작은 값이므로, 계산량 측면에서 매우 유리하고 MF모델의 성능이 준수하고 Scalability가 좋아서 많이 사용됩니다.</p>

<p><img src="../assets/img/posts/image-20220222205911237.png" alt="image-20220222205911237" /></p>

<p>실제 영화 추천 시스템에 예를들어 보자면 다음과 같습니다.</p>

<p><img src="../assets/img/posts/image-20220222211810682.png" alt="image-20220222211810682" /></p>

<p>MF 모델의 목표는 모든 유저와 아이템들에 대해서 K-Dimension 벡터를 벡터를 잘 만드는 것입니다. 벡터를 잘 만드는 기준은 유저 i의 벡터 U_i와 아이템 백터 j의 벡터 I_j를 내적했을 때 유저 i가 아이템 j에 대해 평가한 수치 M_ij와 비슷한지 입니다.</p>

<p><img src="../assets/img/posts/image-20220222212919507.png" alt="image-20220222212919507" /></p>

<p>MF에도 다양한 변형이 있으며, 해당 프로젝트에서 사용할 모델은 <a href="http://yifanhu.net/PUB/cf.pdf">여기 논문</a>에서 제안한 모델입니다.</p>

<h1 id="5-csr-compressed-sparse-row-matrix">5. CSR (Compressed Sparse Row) Matrix</h1>

<p>실제로 평가행렬을 만든다고 생각해 보면, 유저수도 수백명에 아티스트는 29만명이 넘습니다. 평가행렬의 값이 1Byte를 가진다고해도 실제 유저수와 아티스트의 곱인 평가행렬의 크기는 엄청날 것이며, 대부분 0으로 채워질 것입니다.</p>

<p>이 평가행렬의 전부를 메로이에 올려놓고 작업한다는 것은 불가능하며, 그 대안으로 사용되는 것이 CSR Matrix입니다.</p>

<p>CSR Matrix는 Sparse한 matrix에서 0이 아닌 유효한 데이터로만 채우는 Matrix입니다.</p>

<h1 id="6-mf-모델-학습하기">6. MF 모델 학습하기</h1>

<h1 id="7-비슷한-아티스트-찾기--유저에게-추천하기">7. 비슷한 아티스트 찾기 + 유저에게 추천하기</h1>]]></content><author><name>Shin Hwi Jeong</name></author><summary type="html"><![CDATA[오늘은 아이펠 Exploration 노드 14번을 공부하고 공부한 내용을 포스팅해보았습니다.]]></summary></entry><entry><title type="html">강화학습 치팅시트</title><link href="http://localhost:4000/%EA%B0%95%ED%99%94%ED%95%99%EC%8A%B5-%EC%B9%98%ED%8C%85%EC%8B%9C%ED%8A%B8.html" rel="alternate" type="text/html" title="강화학습 치팅시트" /><published>2022-02-22T00:00:00+09:00</published><updated>2022-02-22T00:00:00+09:00</updated><id>http://localhost:4000/%EA%B0%95%ED%99%94%ED%95%99%EC%8A%B5%20%EC%B9%98%ED%8C%85%EC%8B%9C%ED%8A%B8</id><content type="html" xml:base="http://localhost:4000/%EA%B0%95%ED%99%94%ED%95%99%EC%8A%B5-%EC%B9%98%ED%8C%85%EC%8B%9C%ED%8A%B8.html"><![CDATA[<ul>
  <li>
    <p>파이</p>
  </li>
  <li>
    <p>스타</p>
  </li>
  <li>
    <p>파이_뉴= 파이</p>

    <p>​				!= 파이</p>
  </li>
</ul>]]></content><author><name>Shin Hwi Jeong</name></author><summary type="html"><![CDATA[파이]]></summary></entry><entry><title type="html">깃허브 토큰 만들기 + 깃허브 커널에서 깃 올리기</title><link href="http://localhost:4000/%EA%B9%83%ED%97%88%EB%B8%8C-%ED%86%A0%ED%81%B0-%EB%A7%8C%EB%93%A4%EA%B8%B0-+-%EA%B9%83%ED%97%88%EB%B8%8C-%EC%BB%A4%EB%84%90%EC%97%90%EC%84%9C-%EA%B9%83-%EC%98%AC%EB%A6%AC%EA%B8%B0.html" rel="alternate" type="text/html" title="깃허브 토큰 만들기 + 깃허브 커널에서 깃 올리기" /><published>2022-02-21T00:00:00+09:00</published><updated>2022-02-21T00:00:00+09:00</updated><id>http://localhost:4000/%EA%B9%83%ED%97%88%EB%B8%8C%20%ED%86%A0%ED%81%B0%20%EB%A7%8C%EB%93%A4%EA%B8%B0%20+%20%EA%B9%83%ED%97%88%EB%B8%8C%20%EC%BB%A4%EB%84%90%EC%97%90%EC%84%9C%20%EA%B9%83%20%EC%98%AC%EB%A6%AC%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/%EA%B9%83%ED%97%88%EB%B8%8C-%ED%86%A0%ED%81%B0-%EB%A7%8C%EB%93%A4%EA%B8%B0-+-%EA%B9%83%ED%97%88%EB%B8%8C-%EC%BB%A4%EB%84%90%EC%97%90%EC%84%9C-%EA%B9%83-%EC%98%AC%EB%A6%AC%EA%B8%B0.html"><![CDATA[<h1 id="노드복사러에게-남기는-글">노드복사러에게 남기는 글.</h1>

<p>공용 git이기 때문에, 여러분은 (토큰을 생성하지 않았을 시) 토큰생성 먼저 하시고, 3-3의 git clone을 이용하여 작성된 노드들을 올려주시면 됩니다. 그 이후에 추가적으로 글을 올리실 때에는 3-1과 3-2를 참고하여 config 파일작성하고,  fetch , pull 진행해주신 다음 add commit push 명령어를 실행하시면 됩니다.</p>

<p>해당 글은 혹시, 개인적으로 repository를 생성하시고 싶으신 분들을 위해 레포지토리를 아예 생성하는것 부터시작합니다. 참고되셨으면 좋겠네요.</p>

<p>이 이상 문제 생길시, 카톡으로 문의바랍니다.</p>

<hr />

<p>리눅스 커널에서 깃허브를 처음 사용해보는 분들을 위해 작성해 보았습니다.</p>

<p>해당 포스팅은 깃허브에 가입을 하신 상태를 전제로 진행합니다.</p>

<p>리눅스 커널에서 깃허브를 사용하는 방법을 알려드리지만, 깃허브의 add / commit / push등의 용어에 대해서는 설명하지 않습니다.</p>

<h1 id="목차">목차</h1>

<ol>
  <li>깃허브 토큰 만들기
    <ol>
      <li>깃허브 토큰 생성 페이지로 이동하기</li>
      <li>토큰 생성하기</li>
    </ol>
  </li>
  <li>로컬 Git과 Github Repository 연결하기
    <ol>
      <li>Github repository 생성하기</li>
      <li>로컬 Git 생성하기</li>
      <li>Github repository와 로컬 Git 연결하기</li>
      <li>git config 작성하기</li>
    </ol>
  </li>
  <li>Github repository에 파일 push하기
    <ol>
      <li>add와 commit하기</li>
      <li>git branch 생성</li>
      <li>push하기</li>
    </ol>
  </li>
  <li>이미 생성된 repository에 추가로 commit하고 싶다면?
    <ol>
      <li>git fetch와 pull</li>
      <li>git config 작성</li>
      <li>git clone하기</li>
    </ol>
  </li>
</ol>

<h1 id="0-깃허브-토큰-만들기">0. 깃허브 토큰 만들기</h1>

<p>깃허브 토큰은, 로컬 git에서 깃허브로 commit 혹은 pull등의 작업을 할 때 권한을 허가받기 위하여 필요합니다.</p>

<p>생성 방법은 아래에 설명되어 있으며, 토큰 정보는 단 한번만 보이므로 잘 저장해놓아야 합니다.</p>

<h3 id="1-깃허브-토큰-생성-페이지로-이동하기">1. 깃허브 토큰 생성 페이지로 이동하기</h3>

<p>요약 : 깃허브 profile page &gt; Settings &gt; Developers settings &gt; Personal access tokens &gt; Generate new tokens</p>

<p>profile page &gt; settings</p>

<p><img src="../assets/img/posts/image-20220128214631819.png" alt="image-20220128214631819" /></p>

<p>settings &gt; developer settings</p>

<p><img src="../assets/img/posts/image-20220128215412756.png" alt="image-20220128215412756" /></p>

<p>developer settings &gt; Personal access tokens &gt; Generate new tokens</p>

<p><img src="../assets/img/posts/image-20220128215455576.png" alt="image-20220128215455576" /></p>

<h3 id="2-토큰-생성하기">2. 토큰 생성하기</h3>

<p>요약</p>

<ol>
  <li>token 설명 작성</li>
  <li>토큰 사용기한 설정</li>
  <li>토큰 권한 설정</li>
  <li><span style="color:red">토큰 복사 ( 가장 중요 )</span></li>
</ol>

<p><img src="../assets/img/posts/image-20220128220049499.png" alt="image-20220128220049499" /></p>

<ol>
  <li>
    <p>Note : token에 대한 설명을 작성합니다. (skip 가능)</p>
  </li>
  <li>
    <p>Expiration : 토큰 사용기한.</p>

    <p>저는 약 6개월이상, 넉넉히 custom하여 2022-07-15일로 설정해주었습니다.</p>
  </li>
  <li>
    <p>권한 설정</p>
  </li>
</ol>

<p>권한이 많을 수록 편리합니다. 깃허브 사용에 익숙하시지 않으시다면, delete 권한은 주지마세요.</p>

<p>제가 설정한 권한은 다음과 같습니다.</p>

<p><img src="../assets/img/posts/image-20220128220311820.png" alt="image-20220128220311820" /></p>

<ol>
  <li>
    <p><span style="color:red">토큰 복사 ( 가장 중요 )</span></p>

    <p>사진에 가려진 부분은 생성된 토큰입니다.</p>

    <p><span style="color:red">현재밖에 볼 수 없으므로, 메모장등에 꼭 복사해둡니다. pull / push 할 때 항상 사용합니다.</span></p>
  </li>
</ol>

<p><img src="../assets/img/posts/image-20220128220926517.png" alt="image-20220128220926517" /></p>

<h1 id="1-로컬-git과-github-repository-연결하기">1. 로컬 Git과 Github repository 연결하기</h1>

<p>&lt; 요약 &gt;</p>

<ol>
  <li>Github repository 생성하기</li>
  <li>로컬 Git 생성하기</li>
  <li>Github repository와 로컬 Git 연결하기</li>
  <li>git config 작성하기</li>
  <li>Git branch 생성하기</li>
</ol>

<h3 id="1-github-repository-생성하기">1. Github repository 생성하기</h3>

<p>요약 : github profile page &gt; + 버튼 클릭 &gt; New Repository &gt; repository 정보 작성하기 &gt; create repository 버튼 클릭</p>

<p>github profile page &gt; + 버튼 &gt; New Repository</p>

<p><img src="../assets/img/posts/image-20220128224729423.png" alt="image-20220128224729423" style="zoom: 33%;" /></p>

<p>&lt; 아래 그림 설명 &gt;</p>

<p>① : repository이름 작성</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;span style="color:red"&gt;후에 로컬 Git 폴더명과 동일해야 합니다. &lt;/span&gt;

저는 `this_IS_test`라는 repository를 생성했습니다.
</code></pre></div></div>

<p>② : repository에 대한 설명</p>

<p>③ : repository의 Access 설정</p>

<p>④ : repository 초기화 파일</p>

<p>⑤ : 1, 2, 3, 4 설정이 끝난 후, 눌러주면 repository가 생성됩니다.</p>

<p><img src="../assets/img/posts/image-20220128224922791.png" alt="image-20220128224922791" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>깃허브 초보자가 리눅스 커널에서 git을 사용하려 할 때, 초기화 파일을 추가 하지 않는 것을 추천드립니다.

로컬 git에서 깃허브로 push할 때, 로컬 git의 상태가 깃허브의 repository 최신상태와 동일해야 합니다. (fetch &amp; pull한 상태 / 혹은 git clone한 직후.) 깃허브 repository 의 최신 상태와 동일하지 않으면 git push 명령어가 먹히지 않으므로, 초보자에게는 repository의 초기화파일을 만들지 않는 것을 추천드립니다. repository의 상태가 변경되기 때문입니다.
</code></pre></div></div>

<p>초기화 파일을 선택하지 않았을 시, 완료 화면</p>

<p><img src="../assets/img/posts/image-20220128231024990.png" alt="image-20220128231024990" /></p>

<h3 id="2-로컬-git-생성하기">2. 로컬 Git 생성하기</h3>

<p>요약</p>

<ol>
  <li>리눅스에서 repository명과 동일한 폴더 만들기</li>
  <li>
    <p>git init</p>
  </li>
  <li>
    <p>리눅스에서 repository명과 동일한 폴더 만들기</p>

    <p>대소문자 구분해야합니다. 일부로 이름을 <code class="language-plaintext highlighter-rouge">this_IS_test</code>이렇게 한 것은, 대소문자 구분을 해주어야 함을 보여주기 위함입니다. 다음은 리눅스에서 this_IS_test 디렉토리를 만든 화면입니다.</p>

    <p>실행화면</p>

    <p><img src="../assets/img/posts/image-20220128231441275.png" alt="image-20220128231441275" /></p>

    <p>리눅스에서 사용한 명령어</p>

    <blockquote>
      <p>$ mkdir 폴더명</p>
    </blockquote>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;span style="color:red"&gt;이때 폴더명은 repository와 동일한 이름이어야 합니다. &lt;/span&gt;
</code></pre></div>    </div>
  </li>
  <li>
    <p>git init</p>

    <p>이 폴더를 Git으로 사용하겠다는 설정으로, 생성한 로컬 git 폴더로 이동하여 <code class="language-plaintext highlighter-rouge">git init</code>명령어를 사용합니다.</p>

    <p>실행화면</p>

    <p><img src="../assets/img/posts/image-20220128231910283.png" alt="image-20220128231910283" /></p>

    <p>리눅스에서 사용한 명령어</p>

    <blockquote>
      <p>$ cd 폴더명</p>

      <p>$ git init</p>
    </blockquote>
  </li>
</ol>

<h3 id="3-github-repository와-로컬-git-연결하기">3. Github repository와 로컬 Git 연결하기</h3>

<p>요약</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">git remote add origin https://github.com/Nega0619/this_IS_test.git</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">git remote add origin https://github.com/Nega0619/this_IS_test.git</code></p>

    <p>로컬 git 폴더 내에서 위 명령어를 실행해줍니다.</p>

    <p>이때 깃허브 repository 주소는 사진에서 참고하시면 됩니다.</p>

    <p>① : 깃허브의 repository로 이동한 상태에서 URL 복사+.git</p>

    <p>② : 초기 생성화면에서 복사 버튼 클릭하면 됩니다.</p>

    <p><img src="../assets/img/posts/image-20220128232528762.png" alt="image-20220128232528762" /></p>

    <p>실행화면</p>

    <p><img src="../assets/img/posts/image-20220128232649696.png" alt="image-20220128232649696" /></p>

    <p>리눅스에서 사용한 명령어 (이미 로컬 깃내에 존재한다는 전제하에)</p>

    <blockquote>
      <p>$ git remote add origin https://github.com/Nega0619/this_IS_test.git</p>
    </blockquote>
  </li>
</ol>

<h3 id="4-git-config-작성하기">4. git config 작성하기</h3>

<p>요약</p>

<ol>
  <li>git config –global user.email 설정</li>
  <li>git config –global user.name 설정</li>
  <li>git config 파일 확인하기</li>
</ol>

<p>이미 config 작성을 하신적이 있다면 git config -l 로 설정이 되어있는지 확인하세요.</p>

<ol>
  <li>
    <p>git config –global user.email 설정</p>

    <p>“여기안에 이메일” 써야합니다.</p>

    <blockquote>
      <p>$ git config –global user.email “h0riya0619@gmail.com”</p>
    </blockquote>
  </li>
  <li>
    <p>git config –global user.name 설정</p>

    <p>“여기안에 name” 써야합니다.</p>

    <blockquote>
      <p>$ git config –global user.name “Nega0619”</p>
    </blockquote>
  </li>
  <li>
    <p>git config 파일 확인하기</p>

    <blockquote>
      <p>$ git config -l</p>
    </blockquote>

    <p>실행화면</p>

    <p><img src="../assets/img/posts/image-20220128233340161.png" alt="image-20220128233340161" /></p>
  </li>
</ol>

<h1 id="2-repository에-파일-push하기">2. repository에 파일 push하기</h1>

<p>&lt; 요약 &gt;</p>

<ol>
  <li>
    <p>add와 commit하기</p>
  </li>
  <li>
    <p>git branch 생성</p>
  </li>
  <li>
    <p>push하기</p>
  </li>
</ol>

<h3 id="1-add와-commit하기">1. add와 commit하기</h3>

<ul>
  <li>파일 생성하기</li>
</ul>

<p>로컬 깃에서 repository로 push하기 위해선 파일이 잇어야 합니다. 저는 다음 명령어로 파일을 만들어 주었습니다. ( 이미 올릴 파일이 있으면 skip )</p>

<blockquote>
  <p>$ cat &gt; test.txt</p>

  <p>this is test</p>
</blockquote>

<p>여기까지 작성하고 ctrl+z 입력하면 test.txt에 this is test 라는 파일이 생성됩니다.</p>

<p>실행화면</p>

<p><img src="../assets/img/posts/image-20220128234220082.png" alt="image-20220128234220082" /></p>

<ul>
  <li>
    <p>add</p>

    <p>깃에 존재하는 전체 파일을 github에 올리려면 *을 사용하면 됩니다.</p>

    <blockquote>
      <p>$ git add *</p>
    </blockquote>
  </li>
  <li>
    <p>commit</p>

    <p>commit 명령어에서 -m 옵션은 commit 메시지를 설정하는 옵션입니다.</p>

    <p>아래 명령어는 깃으로 commit할때 first commit 이란 메시지로 commit하겠다는 뜻입니다.</p>

    <blockquote>
      <p>$ git commit -m “first commit”</p>
    </blockquote>
  </li>
  <li>
    <p>git commit 상태 확인하기</p>

    <p>현재 add / commit할 파일들에 대한 정보를 보여줍니다.</p>

    <blockquote>
      <p>$ git status</p>
    </blockquote>
  </li>
</ul>

<p>실행화면</p>

<p><img src="../assets/img/posts/image-20220128234528303.png" alt="image-20220128234528303" /></p>

<h3 id="2-git-branch-생성">2. git branch 생성</h3>

<p>main 이라는 이름의 branch를 생성합니다.</p>

<blockquote>
  <p>$ git branch -M main</p>
</blockquote>

<p>실행화면</p>

<p><img src="../assets/img/posts/image-20220128234659996.png" alt="image-20220128234659996" /></p>

<h3 id="3-push하기">3. push하기</h3>

<p>main이란 branch에 git을 push 합니다.</p>

<blockquote>
  <p>$ git push -u origin main</p>

  <p>Username for ‘https://github.com’: 이메일넣기</p>

  <p>Password for ‘https://h0riya0619@gmail.com@github.com’: 토큰넣기</p>
</blockquote>

<p>유의사항</p>

<ul>
  <li>이메일은 “” 등을 사용하지 않고 바로 작성합니다.</li>
  <li>리눅스 환경의 경우, 비밀번호 입력에는 아무것도 보이지 않습니다. 당황하지 마시고 바로 입력하세요
    <ul>
      <li>리눅스 붙여넣기 명령어 : ctrl + shift + v</li>
    </ul>
  </li>
</ul>

<p>실행화면</p>

<p><img src="../assets/img/posts/image-20220128235325441.png" alt="image-20220128235325441" /></p>

<h1 id="3-이미-생성된-repository에-추가로-commit하고-싶다면">3. 이미 생성된 repository에 추가로 commit하고 싶다면?</h1>

<p>처음 repository를 생성하고 파일을 올리는 것과 다르게, 이미 사용하고 있는 repository에 로컬 git을 만들어 파일을 올리고 싶은 경우, add / commit / push가 안되는 경우가 있습니다.</p>

<p>이런 경우, 2가지를 확인해 보면됩니다.</p>

<h3 id="1-git-config-파일-확인하기">1. git config 파일 확인하기</h3>

<p>리눅스 커널에서 git config 파일이 초기화 된경우가 있습니다.</p>

<p>이럴 경우, <code class="language-plaintext highlighter-rouge">git config -l</code>명령어로 config 설정을 먼저 확인해 본 후, 1-4 처럼 user.email과 user.name을 설정을 해주면 됩니다.</p>

<h3 id="2-git-fetch--git-pull-명령어-사용하기">2. git fetch / git pull 명령어 사용하기</h3>

<p>git의 add / commit / push 오류가 나는 경우, 로컬 git의 상태가 git repository 상태와 다른 경우가 많습니다. 이럴때는 fetch와 pull을 해준 후, add / commit / push를 해주면 해결됩니다.</p>

<p>명령어 :</p>

<blockquote>
  <p>$ git fetch</p>

  <p>$ git pull</p>
</blockquote>

<p>fetch와 pull 후, push처럼 이메일과 토큰을 작성해주면 됩니다.</p>

<p>실행화면</p>

<p><img src="../assets/img/posts/image-20220129000155035.png" alt="image-20220129000155035" /></p>

<p>### 3. git clone하기</p>

<p>1, 2로도 해결이안된다 혹은 로컬 깃을 만들지 않은 상태라면, git clone 명령어를 이용해 이미 존재하는 repository를 최신 상태로 로컬에 가져올 수 있습니다.</p>

<p>준비물 : repository URL</p>

<p>명령어</p>

<blockquote>
  <p>$ git clone 깃허브RepositoryURL.git</p>
</blockquote>

<p>실행화면 : 기존에 있던 this_IS_test 로컬 깃을 삭제한 후, clone을 해보았습니다.</p>

<p><img src="../assets/img/posts/image-20220129002245325.png" alt="image-20220129002245325" /></p>

<p>만약 안된다면 config 설정은 해주었는지 확인해보세요~!</p>

<h1 id="아이펠-복사러들에게-git-clone-명령어-선물">아이펠 복사러들에게 git clone 명령어 선물</h1>

<blockquote>
  <p>git clone https://github.com/Nega0619/Aiffel_nodes.git</p>
</blockquote>

<p>실행화면</p>

<p><img src="../assets/img/posts/image-20220129002835862.png" alt="image-20220129002835862" /></p>]]></content><author><name>Shin Hwi Jeong</name></author><summary type="html"><![CDATA[노드복사러에게 남기는 글.]]></summary></entry><entry><title type="html">Scikit Learn ) tranform()과 fit_transform()</title><link href="http://localhost:4000/scikit-learn-)-tranform()%EA%B3%BC-fit_transform().html" rel="alternate" type="text/html" title="Scikit Learn ) tranform()과 fit_transform()" /><published>2022-02-21T00:00:00+09:00</published><updated>2022-02-21T00:00:00+09:00</updated><id>http://localhost:4000/scikit-learn%20)%20tranform()%EA%B3%BC%20fit_transform()</id><content type="html" xml:base="http://localhost:4000/scikit-learn-)-tranform()%EA%B3%BC-fit_transform().html"><![CDATA[<p>https://deepinsight.tistory.com/165</p>

<p>https://velog.io/@classe55/fittransform</p>]]></content><author><name>Shin Hwi Jeong</name></author><summary type="html"><![CDATA[https://deepinsight.tistory.com/165]]></summary></entry><entry><title type="html">[fd_29] 사이킷런을 활용한 추천 시스템 입문</title><link href="http://localhost:4000/fd_29-%EC%82%AC%EC%9D%B4%ED%82%B7%EB%9F%B0%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%B6%94%EC%B2%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%9E%85%EB%AC%B8.html" rel="alternate" type="text/html" title="[fd_29] 사이킷런을 활용한 추천 시스템 입문" /><published>2022-02-21T00:00:00+09:00</published><updated>2022-02-21T00:00:00+09:00</updated><id>http://localhost:4000/%5Bfd_29%5D%20%EC%82%AC%EC%9D%B4%ED%82%B7%EB%9F%B0%EC%9D%84%20%ED%99%9C%EC%9A%A9%ED%95%9C%20%EC%B6%94%EC%B2%9C%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%9E%85%EB%AC%B8</id><content type="html" xml:base="http://localhost:4000/fd_29-%EC%82%AC%EC%9D%B4%ED%82%B7%EB%9F%B0%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%B6%94%EC%B2%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%9E%85%EB%AC%B8.html"><![CDATA[<p>오늘은 아이펠 29번 fundamental 노드를 읽고 공부한 것을 작성해 보았습니다.</p>

<blockquote>
  <p>깃허브 : https://github.com/Nega0619/Aiffel_Fundamental_nodes/blob/main/%5Bfd_29%5D%20Introduction%20to%20the%20recommendation%20system%20using%20scikit-learn.ipynb</p>
</blockquote>

<h6 id="목차">목차</h6>

<ul>
  <li>추천시스템이란?</li>
  <li>유사도 계산</li>
  <li>추천 시스템 종류
    <ul>
      <li>콘텐츠 기반 필터링</li>
      <li>협업 필터링
        <ul>
          <li>사용자 기반</li>
          <li>아이템 기반</li>
          <li>잠재요인 협업 필터링</li>
        </ul>
      </li>
      <li>실제 추천 시스템</li>
    </ul>
  </li>
</ul>

<h1 id="1-추천-시스템이란">1. 추천 시스템이란?</h1>

<blockquote>
  <p>사용자와 관련한 아이템을 추천해주는 것</p>
</blockquote>

<p>이라고 한마디로 정의할 수 있습니다.</p>

<p>영화 추천 시스템을 예로 설명해보겠습니다.</p>

<p>실제 추천 시스템에서는 영화를 아래 사진처럼 좌표평면에 표현합니다.</p>

<p>수식을 이용해 정교하게 그리지만, 대략적으로 그리면 다음과 같습니다.</p>

<p><img src="../assets/img/posts/image-20220221104115455.png" alt="image-20220221104115455" /></p>

<p>이렇게 놓고 보면 거리가 가까운 영화들은 장르가 비슷하다고 생각할 수 있으며, 사용자의 선호도가 어디에 위치하느냐에 따라 사용자에게 맞는 영화를 추천해 줄 수 있습니다.</p>

<p>이러한 추천은 사용자가 이용한 콘텐츠를 기반으로 추천해 주는 방식입니다. 하지만 만약 뉴비 사용자가 나타났다면 어떻게 추천을 해줄까요?</p>

<p>보통은 취향에 대한 정보를 받도록 설문조사가 배치되어있지만 전부 다 스킵하고 정말 인적사항만 아는 사용자의 경우가 있습니다. 이 경우, 뉴비 사용자의 인적사항과 기존 회원들의 인적사항을 분석하여 유사도를 측정하고, 뉴비 사용자에게 유사한 인적사항을 가진 사용자의 선호를 추천해주게 됩니다.</p>

<p>간단한 추천 로직이며, 이를 통해 두가지를 꼭 기억해야 합니다.</p>

<ol>
  <li>
    <p>범주형 데이터를 다룬다.</p>

    <p>이산적, 혹은 범주형이라고 합니다. 액션 / 로맨스 / 호러 등 카테고리가 나뉜 형태의 데이터입니다.</p>
  </li>
  <li>
    <p>(숫자 벡터로 변환한 후) 유사도를 계산한다.</p>

    <p>범주형 데이터를 좌표에 나타내기 위하여 숫자로 이루어진 벡터로 변환합니다.(numerical vector) 그리고 그 거리를 계산해 유사도를 측정합니다.</p>
  </li>
</ol>

<h1 id="2-코사인-유사도">2. 코사인 유사도</h1>

<p>가장 유명한 유사도를 계산하는 방법입니다. 코사인 유사도는 두 벡터간의 코사인값을 계산하여 유사도를 측정하게됩니다.</p>

<p>코사인 유사도는 두 벡터가 방향이 이루는 각도에 코사인을 취해 구합니다.</p>

<p><img src="../assets/img/posts/image-20220221105201542.png" alt="image-20220221105201542" /></p>

<p>위 그림은 두 벡터가 이루는 각도에 따른 유사도입니다. 1에 가까울 수록 유사도가 높다고 할 수 있습니다. 수식은 다음과 같습니다.</p>

<p><img src="../assets/img/posts/image-20220221105248414.png" alt="image-20220221105248414" /></p>

<h3 id="numpy를-이용한-코사인-유사도">numpy를 이용한 코사인 유사도</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">dot</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">norm</span>
<span class="k">def</span> <span class="nf">cos_sim</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
	<span class="k">return</span> <span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">*</span><span class="n">norm</span><span class="p">(</span><span class="n">B</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="사이킷-런을-활용한-코사인-유사도">사이킷 런을 활용한 코사인 유사도</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">sklearn.metrics.pairwise</span> <span class="kn">import</span> <span class="n">cosine_similarity</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="n">cosine_similarity</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span><span class="n">t2</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="다른-방법의-유사도-측정방법">다른 방법의 유사도 측정방법</h3>

<p>유클리드 거리 / 자카드 유사도 / 피어슨 상관계수 등의 방법이 있습니다.</p>

<h1 id="3-추천-시스템의-종류">3. 추천 시스템의 종류</h1>

<ul>
  <li>
    <p>콘텐츠 기반 필터링 (Content Based Filtering)</p>
  </li>
  <li>
    <p>협업 기반 필터링 (Collaborative Filtering</p>

    <ul>
      <li>사용자 기반</li>
      <li>아이템 기반</li>
      <li>잠재요인 협업 필터링 (latent factor collaborative filtering) → 행렬 인수분해(matrix factorization)</li>
    </ul>
  </li>
  <li>
    <p>DeepLearning 적용</p>
  </li>
  <li>
    <p>Hybrid방식</p>

    <p>여러 방법을 결합한 방식</p>
  </li>
</ul>

<h2 id="3-1-콘텐츠-기반-필터링-방식">3-1. 콘텐츠 기반 필터링 방식</h2>

<p>콘텐츠 기반은 오직 콘텐츠의 내용만을 비교해 추천하는 방식입니다.</p>

<p>아까 예를 들었던 영화로 말하자면, 사람들이 영화를 볼때 고려하는 점은 다음과 같습니다. 장르, 배우, 감독 등의 정보. 이러한 요소들을 영화의 <strong>특성(Feature)</strong>이라고 하고 이 특성을 바탕으로 콘텐츠의 유사도를 측정하게 됩니다.</p>

<ul>
  <li>코드</li>
</ul>

<p><strong>해당 예제는 CODE HEROKU의 <a href="http://www.codeheroku.com/post.html?name=Building a Movie Recommendation Engine in Python using Scikit-Learn">‘Building a Movie Recemmendation Engine in Python using Scikit-Learn’</a> 을 바탕으로 제작되었습니다.</strong></p>

<blockquote>
  <p>전체코드는 깃허브를 참고하시고, 블로그에는 새로 배운 것 위주로 작성하였습니다.</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">sklearn.feature_extraction.text</span> <span class="kn">import</span> <span class="n">CountVectorizer</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics.pairwise</span> <span class="kn">import</span> <span class="n">cosine_similarity</span>
</code></pre></div></div>

<ul>
  <li>
    <p>os.getcwd() : 현재 파일이 실행되고 있는 working directory 출력</p>
  </li>
  <li>
    <p>scikit-learn.CountVectorize() : 단순하게 등장 횟수를 세어 숫자 벡터로 만들어줌.</p>

    <ul>
      <li>
        <p>out : CSR(Compressed Sparse Row) Matrix</p>

        <p>CSR Matrix란?</p>

        <p>Sparse한 matrix에서 0이 아닌 데이터로 채워지는 데이터 값과 좌표 정보로만으로 구성하여 메모리 사용량을 최소화하고 Sparse한 matrix와 동일한 행렬을 표현할 수 있도록 하는 데이터 구조</p>
      </li>
    </ul>
  </li>
  <li>
    <p>CountVectorize().fit_transform(pandas.dataframe)</p>

    <ul>
      <li>데이터에 맞춘 다음 변환합니다.</li>
    </ul>
  </li>
  <li>
    <p>cosine_similarity() : 코사인 유사도를 구하는 메소드</p>

    <ul>
      <li>in : CSR Matrix</li>
    </ul>
  </li>
</ul>

<h2 id="3-2-협업-필터링-방식">3-2. 협업 필터링 방식</h2>

<p>과거의 사용자 행동 양식(User Behavior) 데이터를 기반으로 추천하는 방식으로, 잠재요인 기법을 활용하여 행동 양식을 데이터로 나타냄</p>

<h3 id="기본원리">기본원리</h3>

<p><img src="../assets/img/posts/image-20220221144819086.png" alt="image-20220221144819086" /></p>

<p>다음과 같은 테이블이 있다고 생각해봅시다. timestamp는 사용자가 평점을 매긴 시간입니다. 위 데이터를 사용자와 아이템간의 interaction matrix로 변환해봅시다. 그리고 해당 행렬의 데이터로 평점을 넣으면 아래와 같은 형식이 됩니다. 이를 평점행렬이라고 부르기도 합니다.</p>

<p><img src="../assets/img/posts/image-20220221144944827.png" alt="image-20220221144944827" /></p>

<p>이러한 행렬은 굉장히 희소(sparse)한 행렬이 됩니다.</p>

<p>평점 행렬로 변환 후, 평점 행렬의 유사도를 계산하여 추천하는 방식 : 사용자기반, 아이템 기반 방식</p>

<p>평점행렬을 분해하여 더 많은 정보를 고려하는 방식 : 잠재요인 필터링</p>

<p>정리하자면 다음과 같습니다.</p>

<ul>
  <li>협업 필터링의 종류
    <ul>
      <li>사용자 기반
        <ul>
          <li>유사도 계산방식</li>
        </ul>
      </li>
      <li>아이템 기반
        <ul>
          <li>유사도 계산방식</li>
        </ul>
      </li>
      <li>잠재요인 기반
        <ul>
          <li>행렬인수분해 방식</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="사용자기반">사용자기반</h3>

<blockquote>
  <p>당신과 비슷한 고객들이 다음 상품을 구매했습니다.</p>
</blockquote>

<p>위 글을 시스템으로 만든 것이 사용자 기반 추천시스템입니다.</p>

<p><img src="../assets/img/posts/image-20220221154853846.png" alt="image-20220221154853846" /></p>

<p>user 4가 아이템 1을 구매하고, user 4와 가장 유사한 user 2는 아이템 1-4까지 위와 같은 평점을 남겼다고 합시다. 이 경우, user2가 선호한 제품인 item 3을 4에게 추천해주는 방식입니다.</p>

<h3 id="아이템기반">아이템기반</h3>

<blockquote>
  <p>이 상품을 선택한 다른 고객들은 다음 상품을 구매했습니다.</p>
</blockquote>

<p>위 말을 시스템으로 만든 것이 아이템 기반 추천 시스템입니다. 일반적으로 사용자 기반보다는 아이템 기반 방식이 정확도가 높다고 합니다.</p>

<p><img src="../assets/img/posts/image-20220221155923256.png" alt="image-20220221155923256" /></p>

<p>user2가 위와 같은 선호도를 가졌다할 때, 아이템 1의 선호도가 가장 높습니다.</p>

<p>그리고 아이템 1의 선호도는 다음과 같습니다.</p>

<p><img src="../assets/img/posts/image-20220221155952136.png" alt="image-20220221155952136" /></p>

<p>아이템 2을 좋아한 사람은 user4이므로 user4에게 user2가 좋아한 상품인 3을 추천해줍니다.</p>

<p><img src="../assets/img/posts/image-20220221160008483.png" alt="image-20220221160008483" /></p>

<h3 id="잠재요인-협업-필터링-기반">잠재요인 협업 필터링 기반</h3>

<p>평점행렬을 행렬 인수분해(matrix factorization)를 통해 잠재요인(latent factor)을 분석</p>

<p>행렬 인수분해 종류</p>

<ul>
  <li>SVD(Singular Vector Decomposition)</li>
  <li>ALS(Alternating Least Squares)</li>
  <li>NMF(Non-Negative Factorization)</li>
</ul>

<h4 id="svd-singular-vector-decomposition">SVD Singular Vector Decomposition</h4>

<p>가장 많이 사용됨, 우리말로는 특잇값 분해</p>

<p>M*N 형태의 행렬 A를 다음과 같은 형태로 분해하여 나타냄</p>

<p><img src="../assets/img/posts/image-20220221171929948.png" alt="image-20220221171929948" /></p>

<ul>
  <li>
    <p>구현 메소드 : https://numpy.org/doc/stable/reference/generated/numpy.linalg.svd.html</p>
  </li>
  <li>코드
    <ul>
      <li>np.diag(Sigma) : 대각선을 추출하거나 대각선 배열을 구성합니다.</li>
      <li>np.dot(np.dot(U, Sigma_mat), VT) : 두 배열간의 내적</li>
    </ul>
  </li>
  <li>
    <p>참고 링크</p>

    <ul>
      <li>
        <p><a href="https://angeloyeo.github.io/2019/08/01/SVD.html">특잇값분해</a></p>
      </li>
      <li>
        <p>[<a href="https://darkpgmr.tistory.com/106">선형대수학 #4] 특이값 분해(Singular Value Decomposition, SVD)의 활용</a></p>
      </li>
    </ul>
  </li>
</ul>

<h4 id="truncated-svd--lsa-latent-sementic-analysis">Truncated SVD = LSA Latent Sementic Analysis</h4>

<p>우리말로 번역하면 잘린 SVD, 다른 말로는 LSA(Latent semantic analysis), 잠재 의미 분석 이라고 합니다.</p>

<p>Truncated SVD를 이용해 분해한 뒤, 복원하면 SVD처럼 완벽히 나오지않습니다. 왜냐하면 Truncated SVD가 차원을 축소한 다음 행렬을 분해하기 때문입니다.</p>

<p>SVD(특이값 분해)를 평가행렬에 적용해 잠재요인을 분석하는 것을 도식화하면 사진과 같습니다.</p>

<p><img src="../assets/img/posts/image-20220221174558265.png" alt="image-20220221174558265" /></p>

<p>표기법</p>

<ul>
  <li>R: 사용자와 아이템 사이의 행렬</li>
  <li>P: 사용자와 잠재요인 사이의 행렬</li>
  <li>Q: 아이템과 잠재요인 사이의 행렬 —&gt; 전치 행렬 형태로 나타냄</li>
</ul>

<p><img src="../assets/img/posts/image-20220221174851001.png" alt="image-20220221174851001" /></p>

<p>사용자가 아이템에 대한 평점을 매기는 요인으로 많은 항목들이 있습니다. 그리고 평점을 매기는 것은 매우 주관적입니다. 그렇기 때문에, 사용자가 평점을 매기는 요인을 잠재요인으로 취급한 뒤, SVD 기법을 이용해 분해하고, 다시 합치는 방법으로 영화에 평점을 매긴 이유를 벡터화하고 이를 기반으로 추천합니다. 이 기법은 넷플릭스, 왓챠, 유튜브와 같은 기업에서 효과를 입증해냈고 이후 많은 기업들도 채택하였다고 합니다.</p>

<p>이렇게 협업 필터링을 이용하면 사용자가 아이템에 대해 평점을 매긴 평점행렬을 인수분해(Matrix Factorization)를 통해 잠재요인을 분석한 뒤 유사도를 계산할 수도 있으며 사용자의 평점도 예측할 수 있습니다. 특히 잠재요인을 고려해 행렬을 인수분해하면 파라미터수는 감소하게 됩니다.</p>

<p>구현 메소드 : https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.TruncatedSVD.html</p>

<h2 id="3-3-실제-추천-시스템">3-3. 실제 추천 시스템</h2>

<p>오늘 작성한 내용들은 추천 시스템에 기본이 되는 요소입니다. 실제로 대기업에서는 더 많은 것을 추천에 고려합니다.</p>

<p>사용자의 구매여부, 평점데이터는 기본이고 얼마나 오랜 시간 시청(혹은 사이트에 머물렀는지)했는지, 어떤 사이트에서 유입되었는지, 시청 후 구매로 이어지기까지의 시간 등 행동 족적을 다 분석합니다. 이를 전문 용어로 <strong>Digital Footprint(디지털 발자국), Digital Shadow(디지털 그림자)</strong>라고 합니다.</p>

<p>이중 가장 중요한 지표가 **클릭룰( CTR , Click Through Rate) **입니다.</p>

<ul>
  <li>참고: <a href="https://support.google.com/google-ads/answer/2615875?hl=en">Clickthrough rate (CTR): Definition</a></li>
</ul>

<p>어떻게든 다양한 데이터들을 모아 추천을 한 뒤, 적절한 추천이었는지 아니었는지를 평가하는 것 또한 중요한 일입니다. 추천한 제품이 구매 혹은 시청으로 이루어졌는지를 통해 추천의 성공여부를 평가하기도 하고, 모델 단계에서 평가하기도 합니다.</p>

<p>추천시스템은 매우 큰 시스템입니다. 데이터를 기반으로 고객에게 적절한 제품 혹은 콘텐츠를 추천하고, 이것이 구매 , 결제로 이루어 지는 것은 매출과 직결되는 문제기도 합니다. 좋은 추천 시스템을 만들기 위해서는, 어떤 데이터를 사용할지 매우 고민을 해야합니다. 어떤 데이터가 사용자와 연관성이 있을지, 구매와 직결되는 각종 데이터는 무엇인지 고려하고 수집, 정렬(sorting)하여 다시 순위(ranking)를 매긴 다음 평가하는 작업을 반복하며 적합한 데이터와 추천 시스템이 만들어냅니다.</p>

<blockquote>
  <p>추천시스템이 머신러닝이 적용될 수도 있는거지 머신러닝안에 추천시스템이 있는것은 아닙니다.</p>
</blockquote>

<hr />

<h6 id="출처">출처</h6>

<ul>
  <li>
    <p>AIFFEL LMS</p>

    <p>문제시 연락 부탁드립니다. :)</p>
  </li>
  <li>
    <p>5</p>
  </li>
</ul>]]></content><author><name>Shin Hwi Jeong</name></author><summary type="html"><![CDATA[오늘은 아이펠 29번 fundamental 노드를 읽고 공부한 것을 작성해 보았습니다.]]></summary></entry><entry><title type="html">Git lfs 깃에 100mb보다 큰 파일 올리기</title><link href="http://localhost:4000/Git-LFS-%EA%B9%83%EC%97%90-100MB%EB%B3%B4%EB%8B%A4-%ED%81%B0-%ED%8C%8C%EC%9D%BC-%EC%98%AC%EB%A6%AC%EA%B8%B0.html" rel="alternate" type="text/html" title="Git lfs 깃에 100mb보다 큰 파일 올리기" /><published>2022-02-21T00:00:00+09:00</published><updated>2022-02-21T00:00:00+09:00</updated><id>http://localhost:4000/Git%20LFS%20%EA%B9%83%EC%97%90%20100MB%EB%B3%B4%EB%8B%A4%20%ED%81%B0%20%ED%8C%8C%EC%9D%BC%20%EC%98%AC%EB%A6%AC%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/Git-LFS-%EA%B9%83%EC%97%90-100MB%EB%B3%B4%EB%8B%A4-%ED%81%B0-%ED%8C%8C%EC%9D%BC-%EC%98%AC%EB%A6%AC%EA%B8%B0.html"><![CDATA[<blockquote>
  <p>git lfs install</p>

  <p>git lfs track “*.exe”</p>

  <p>git config –<strong>global</strong> http.postBuffer 20971520</p>

  <p>git config –<strong>global</strong> http.maxRequestBuffer 100M</p>
</blockquote>

<ul>
  <li>git lfs 사이트
    <ul>
      <li>https://git-lfs.github.com/</li>
    </ul>
  </li>
  <li>참고 사이트
    <ul>
      <li>https://jamie-dev.tistory.com/79</li>
      <li>https://goodtogreate.tistory.com/entry/Github%EC%97%90-100Mb%EC%9D%B4%EC%83%81-%ED%8C%8C%EC%9D%BC-%EC%98%AC%EB%A6%AC%EB%8A%94-%EB%B0%A9%EB%B2%95-%EC%98%A4%EB%A5%98-%ED%95%B4%EA%B2%B0</li>
      <li>https://medium.com/@stargt/github%EC%97%90-100mb-%EC%9D%B4%EC%83%81%EC%9D%98-%ED%8C%8C%EC%9D%BC%EC%9D%84-%EC%98%AC%EB%A6%AC%EB%8A%94-%EB%B0%A9%EB%B2%95-9d9e6e3b94ef</li>
    </ul>
  </li>
</ul>]]></content><author><name>Shin Hwi Jeong</name></author><summary type="html"><![CDATA[git lfs install git lfs track “*.exe” git config –global http.postBuffer 20971520 git config –global http.maxRequestBuffer 100M]]></summary></entry></feed>